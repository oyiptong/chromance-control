#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
WLED_DIR="${ROOT_DIR}/tools/wled_spike/wled"

if [[ ! -d "${WLED_DIR}" ]]; then
  echo "Missing WLED clone at: ${WLED_DIR}"
  echo "Clone it with:"
  echo "  git clone --depth 1 https://github.com/Aircoookie/WLED.git tools/wled_spike/wled"
  exit 1
fi

cp "${ROOT_DIR}/tools/wled_spike/platformio_override.chromance_spike.ini" "${WLED_DIR}/platformio_override.ini"

mkdir -p "${WLED_DIR}/usermods/chromance_spike"
cp "${ROOT_DIR}/tools/wled_spike/usermods/chromance_spike/library.json" "${WLED_DIR}/usermods/chromance_spike/library.json"
cp "${ROOT_DIR}/tools/wled_spike/usermods/chromance_spike/chromance_spike.cpp" "${WLED_DIR}/usermods/chromance_spike/chromance_spike.cpp"

# Patch WLED to support sparse 2D ledmaps where map.length == width*height > LED_COUNT.
# Upstream WLED currently allocates the mapping table to LED_COUNT and truncates the map,
# which causes large parts of Chromance to remain dark when ledmap.json is enabled.
FX_FCN="${WLED_DIR}/wled00/FX_fcn.cpp"
if [[ -f "${FX_FCN}" ]]; then
  python3 - <<'PY'
from __future__ import annotations

from pathlib import Path

path = Path("tools/wled_spike/wled/wled00/FX_fcn.cpp")
text = path.read_text(encoding="utf-8", errors="ignore")

if "const uint32_t mapSize = isMatrix ? static_cast<uint32_t>(Segment::maxWidth) * Segment::maxHeight" not in text:
    old_alloc = "customMappingTable = static_cast<uint16_t*>(d_malloc(sizeof(uint16_t)*getLengthTotal())); // prefer DRAM for speed"
    old_break = "if (customMappingSize >= getLengthTotal()) break;"

    if old_alloc not in text or old_break not in text:
        raise SystemExit("Expected WLED ledmap allocation/truncation code not found; upstream may have changed.")

    text = text.replace(
        "d_free(customMappingTable);\n  " + old_alloc + "\n\n  if (customMappingTable) {\n    DEBUG_PRINTF_P(PSTR(\"ledmap allocated: %uB\\n\"), sizeof(uint16_t)*getLengthTotal());",
        "d_free(customMappingTable);\n"
        "  const uint32_t mapSize = isMatrix ? static_cast<uint32_t>(Segment::maxWidth) * Segment::maxHeight : getLengthTotal();\n"
        "  customMappingTable = static_cast<uint16_t*>(d_malloc(sizeof(uint16_t)*mapSize)); // prefer DRAM for speed\n\n"
        "  if (customMappingTable) {\n"
        "    for (uint32_t i = 0; i < mapSize; ++i) customMappingTable[i] = 0xFFFFU;\n"
        "    DEBUG_PRINTF_P(PSTR(\"ledmap allocated: %uB\\n\"), sizeof(uint16_t)*mapSize);"
    )
    text = text.replace(old_break, "if (customMappingSize >= mapSize) break;")
    path.write_text(text, encoding="utf-8")
PY
  echo "Patched WLED ledmap loader to support sparse 2D maps (mapSize=width*height)."
else
  echo "Warning: missing ${FX_FCN}; skipping WLED ledmap loader patch."
fi

# WLED WebUI currently hard-caps “2 pin” (SPI) busses to 2 via UI validation.
# For the Chromance spike we need 4 APA102 busses; the firmware supports more,
# so patch the UI in the local clone.
LED_UI="${WLED_DIR}/wled00/data/settings_leds.htm"
if [[ -f "${LED_UI}" ]]; then
  python3 - <<'PY'
from __future__ import annotations

from pathlib import Path

path = Path("tools/wled_spike/wled/wled00/data/settings_leds.htm")
text = path.read_text(encoding="utf-8", errors="ignore")

old = "if (twopinB >= 2 && !isD2P(curType)) disable('option[data-type=\"2P\"]');"
new = "if (twopinB >= 4 && !isD2P(curType)) disable('option[data-type=\"2P\"]');"

if new in text:
    raise SystemExit(0)
if old not in text:
    raise SystemExit("Expected 2-pin bus cap line not found; WLED UI may have changed upstream.")

path.write_text(text.replace(old, new), encoding="utf-8")
PY
  echo "Patched WLED WebUI to allow up to 4 SPI (2-pin) LED busses."
else
  echo "Warning: missing ${LED_UI}; skipping WLED WebUI patch for SPI bus count."
fi

WIFI_SECRETS="${ROOT_DIR}/include/wifi_secrets.h"
AUTOGEN_HDR="${WLED_DIR}/wled00/chromance_spike_autogen.h"
if [[ -f "${WIFI_SECRETS}" ]]; then
  WIFI_SSID=""
  WIFI_PASSWORD=""
  idx=0
  while IFS= read -r line; do
    if [[ ${idx} -eq 0 ]]; then
      WIFI_SSID="${line}"
    elif [[ ${idx} -eq 1 ]]; then
      WIFI_PASSWORD="${line}"
    fi
    idx=$((idx + 1))
  done < <(
    python3 - <<'PY'
import re
from pathlib import Path

path = Path("include/wifi_secrets.h")
text = path.read_text(encoding="utf-8", errors="ignore")

def find_define(name: str) -> str | None:
    m = re.search(rf'^\s*#\s*define\s+{re.escape(name)}\s+"([^"]*)"\s*$', text, flags=re.M)
    return m.group(1) if m else None

def c_escape(s: str) -> str:
    return s.replace("\\", "\\\\").replace('"', '\\"')

ssid = find_define("WIFI_SSID")
pw = find_define("WIFI_PASSWORD")
print(c_escape(ssid) if ssid else "")
print(c_escape(pw) if pw else "")
PY
  )

  if [[ -n "${WIFI_SSID}" && -n "${WIFI_PASSWORD}" ]]; then
    cat > "${AUTOGEN_HDR}" <<EOF
#pragma once

// AUTOGENERATED by tools/wled_spike/install_into_wled.sh
// Sourced from include/wifi_secrets.h (Chromance repo).
// Do not commit this file; it lives inside the local WLED clone (gitignored).

#define CLIENT_SSID "${WIFI_SSID}"
#define CLIENT_PASS "${WIFI_PASSWORD}"
EOF
    if ! rg -q "chromance_spike_autogen\\.h" "${WLED_DIR}/wled00/my_config.h"; then
      cat >> "${WLED_DIR}/wled00/my_config.h" <<'EOF'

// Chromance spike: seed WLED WiFi defaults from include/wifi_secrets.h
#include "chromance_spike_autogen.h"
EOF
    fi
    echo "Applied WiFi defaults from include/wifi_secrets.h into local WLED clone."
  else
    echo "include/wifi_secrets.h present, but WIFI_SSID/WIFI_PASSWORD could not be parsed; skipping WiFi defaults."
  fi
else
  echo "include/wifi_secrets.h not found; WiFi must be configured via WLED AP WebUI."
fi

echo "Installed Chromance spike files into:"
echo "  ${WLED_DIR}"
echo ""
echo "Next:"
echo "  (cd tools/wled_spike/wled && pio run -e chromance_spike_featheresp32)"
