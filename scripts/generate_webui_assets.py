import gzip
import json
import os
import subprocess
from dataclasses import dataclass
from pathlib import Path

Import("env")


@dataclass(frozen=True)
class Asset:
    request_path: str
    src_path: Path
    gz_path: Path
    gz_len: int
    content_type: str
    cache_control: str


SOFT_BUDGET_BYTES = 200 * 1024
HARD_BUDGET_BYTES = 300 * 1024

CHUNK_THRESHOLD_BYTES = 1024

FORBIDDEN_PACKAGES = [
    # routers
    "react-router",
    "preact-router",
    # global state
    "redux",
    "zustand",
    "mobx",
    "recoil",
    # charts
    "chart.js",
    "d3",
    "echarts",
    # syntax highlighting
    "prismjs",
    "highlight.js",
    # date libs
    "moment",
    "dayjs",
    "date-fns",
    "luxon",
    # color pickers
    "react-colorful",
    "iro.js",
]


def _content_type_for(path: str) -> str:
    ext = Path(path).suffix.lower()
    if ext == ".html":
        return "text/html; charset=utf-8"
    if ext == ".css":
        return "text/css; charset=utf-8"
    if ext == ".js":
        return "application/javascript; charset=utf-8"
    if ext == ".svg":
        return "image/svg+xml"
    if ext == ".ico":
        return "image/x-icon"
    return "application/octet-stream"


def _cache_control_for(request_path: str) -> str:
    # Fingerprinted assets: cache forever. Shell pages: no-store.
    if request_path.startswith("/assets/"):
        return "public, max-age=31536000, immutable"
    return "no-store"


def _gzip_deterministic(src: Path, dst: Path) -> int:
    dst.parent.mkdir(parents=True, exist_ok=True)
    with src.open("rb") as f_in, dst.open("wb") as f_out:
        with gzip.GzipFile(filename="", mode="wb", fileobj=f_out, mtime=0) as gz:
            gz.write(f_in.read())
    return dst.stat().st_size


def _scan_lockfile_for_forbidden(lockfile: Path) -> None:
    if not lockfile.exists():
        raise RuntimeError(f"missing lockfile: {lockfile}")
    # Lockfile scan is intended to prevent *explicit* inclusion of forbidden frontend dependencies.
    # Tooling transitive deps (e.g. build-time highlighters used by Astro itself) are not part of the shipped UI.
    data = json.loads(lockfile.read_text(encoding="utf-8"))
    root = None
    if isinstance(data, dict) and isinstance(data.get("packages"), dict):
        root = data["packages"].get("")
    if not isinstance(root, dict):
        raise RuntimeError(f"unexpected package-lock format: {lockfile}")

    declared = set()
    for k in ("dependencies", "devDependencies", "optionalDependencies", "peerDependencies"):
        deps = root.get(k)
        if isinstance(deps, dict):
            declared.update(deps.keys())

    def is_forbidden(name: str) -> bool:
        n = name.lower()
        for f in FORBIDDEN_PACKAGES:
            ff = f.lower()
            if n == ff:
                return True
            if n.startswith(ff + "-") or n.startswith(ff + "/"):
                return True
        return False

    hits = sorted([name for name in declared if is_forbidden(name)])
    if hits:
        raise RuntimeError(f"forbidden frontend dependencies declared in {lockfile.name}: {', '.join(hits)}")


def _assert_no_sourcemaps(dist_dir: Path) -> None:
    maps = list(dist_dir.rglob("*.map"))
    if maps:
        raise RuntimeError(f"source maps forbidden in webui/dist (found {len(maps)} .map files)")


def _sym_for(request_path: str) -> str:
    # "/settings/index.html" -> "asset_settings_index_html"
    s = request_path.strip("/")
    out = ["asset"]
    for c in s:
        if c.isalnum():
            out.append(c)
        else:
            out.append("_")
    return "_".join("".join(out).split("_"))


def _emit_header(out_path: Path, assets: list[Asset]) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)

    lines: list[str] = []
    lines.append("#pragma once")
    lines.append("")
    lines.append("// Auto-generated by scripts/generate_webui_assets.py")
    lines.append("")
    lines.append("#include <stddef.h>")
    lines.append("#include <stdint.h>")
    lines.append("#include <string.h>")
    lines.append("")
    lines.append("struct WebuiAsset {")
    lines.append("  const char* request_path;")
    lines.append("  const char* content_type;")
    lines.append("  const char* cache_control;")
    lines.append("  const uint8_t* gz_data;")
    lines.append("  size_t gz_len;")
    lines.append("};")
    lines.append("")

    for a in assets:
        sym = _sym_for(a.request_path)
        data = a.gz_path.read_bytes()
        lines.append(f"static const uint8_t {sym}[] = {{")
        for i in range(0, len(data), 12):
            chunk = data[i : i + 12]
            lines.append("  " + ", ".join(f"0x{b:02X}" for b in chunk) + ",")
        lines.append("};")
        lines.append("")

    lines.append("static const WebuiAsset kWebuiAssets[] = {")
    for a in assets:
        sym = _sym_for(a.request_path)
        lines.append(
            f'  {{ "{a.request_path}", "{a.content_type}", "{a.cache_control}", {sym}, {a.gz_len} }},'
        )
    lines.append("};")
    lines.append("")
    lines.append(
        "static constexpr size_t kWebuiAssetCount = sizeof(kWebuiAssets) / sizeof(kWebuiAssets[0]);"
    )
    lines.append("")
    lines.append("static inline const WebuiAsset* chromance_webui_find_asset(const char* request_path) {")
    lines.append("  if (request_path == nullptr) return nullptr;")
    lines.append("  for (size_t i = 0; i < kWebuiAssetCount; ++i) {")
    lines.append("    const WebuiAsset* a = &kWebuiAssets[i];")
    lines.append("    if (a->request_path != nullptr && strcmp(a->request_path, request_path) == 0) return a;")
    lines.append("  }")
    lines.append("  return nullptr;")
    lines.append("}")
    lines.append("")

    out_path.write_text("\n".join(lines), encoding="utf-8")


project_dir = Path(env["PROJECT_DIR"])
webui_dir = project_dir / "webui"
dist_dir = webui_dir / "dist"
gz_dir = webui_dir / "dist_gz"

include_generated = project_dir / "include" / "generated"
out_header = include_generated / "webui_assets.h"

node = os.environ.get("NODE", "node")
npm = os.environ.get("NPM", "npm")


def main() -> None:
    if not webui_dir.exists():
        raise RuntimeError("webui/ directory missing; see docs/plans/webui_design_doc.md for required structure")

    _scan_lockfile_for_forbidden(webui_dir / "package-lock.json")

    subprocess.check_call([npm, "ci"], cwd=str(webui_dir))
    subprocess.check_call([npm, "run", "build"], cwd=str(webui_dir))

    if not dist_dir.exists():
        raise RuntimeError("Astro build did not produce webui/dist")

    _assert_no_sourcemaps(dist_dir)

    assets: list[Asset] = []
    total = 0
    for src in sorted([p for p in dist_dir.rglob("*") if p.is_file()]):
        rel = src.relative_to(dist_dir).as_posix()
        request_path = "/" + rel
        gz_path = gz_dir / (rel + ".gz")
        gz_len = _gzip_deterministic(src, gz_path)
        total += gz_len
        assets.append(
            Asset(
                request_path=request_path,
                src_path=src,
                gz_path=gz_path,
                gz_len=gz_len,
                content_type=_content_type_for(request_path),
                cache_control=_cache_control_for(request_path),
            )
        )

    report = {
        "total_gz_bytes": total,
        "soft_budget_bytes": SOFT_BUDGET_BYTES,
        "hard_budget_bytes": HARD_BUDGET_BYTES,
        "chunk_threshold_bytes": CHUNK_THRESHOLD_BYTES,
        "assets": [
            {
                "path": a.request_path,
                "gz_bytes": a.gz_len,
                "content_type": a.content_type,
                "cache_control": a.cache_control,
            }
            for a in assets
        ],
    }
    (webui_dir / "dist_gz_size_report.json").write_text(json.dumps(report, indent=2), encoding="utf-8")
    (webui_dir / "dist_gz_size_report.txt").write_text(
        "\n".join([f"{a.gz_len:7d}  {a.request_path}" for a in sorted(assets, key=lambda x: -x.gz_len)])
        + f"\n\nTOTAL: {total}\n",
        encoding="utf-8",
    )

    if total > HARD_BUDGET_BYTES:
        raise RuntimeError(f"webui assets exceed hard budget: {total} > {HARD_BUDGET_BYTES} bytes (gzipped total)")
    if total > SOFT_BUDGET_BYTES:
        print(f"WARNING: webui assets exceed soft budget: {total} > {SOFT_BUDGET_BYTES} bytes (gzipped total)")

    _emit_header(out_header, assets)
    print(f"Generated {out_header}")


main()
